<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Primal Simulation - Wood & Storage</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f4f8;
        }
        canvas {
            border: 1px solid #ccc;
            background-color: #e2f0d9;
            cursor: pointer;
            display: block;
            max-width: 100%;
            height: auto;
        }
        .controls {
            margin-left: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 220px; /* Increased min-width */
        }
        .human-info p, .storage-info p {
            margin-bottom: 5px;
            font-size: 0.9rem; /* Slightly smaller font */
        }
         .storage-info {
             margin-top: 15px;
             padding-top: 10px;
             border-top: 1px solid #eee;
         }
        .progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            height: 15px;
            margin-top: 2px;
        }
        .progress-bar {
            height: 100%;
            background-color: #4caf50; /* Green */
            width: 0%;
            transition: width 0.3s ease;
            text-align: center;
            color: white;
            font-size: 10px;
            line-height: 15px;
        }
         .progress-bar.low { background-color: #ff9800; } /* Orange */
         .progress-bar.critical { background-color: #f44336; } /* Red */
        button {
            padding: 8px 15px;
            background-color: #4a90e2; /* Blue button */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 10px;
        }
        button:hover { background-color: #357abd; }
    </style>
</head>
<body class="flex flex-col md:flex-row items-start justify-center p-4">

    <canvas id="simulationCanvas" width="700" height="500"></canvas> <div class="controls mt-4 md:mt-0 md:ml-4 p-4 bg-white rounded-lg shadow-md w-full md:w-auto">
        <h2 class="text-lg font-semibold mb-3">Simulation Info</h2>
        <div id="selectedHumanInfo" class="human-info mb-4">
            <p>Select a human to see details.</p>
        </div>
        <div id="storageInfo" class="storage-info">
            <h3 class="text-md font-semibold mb-2">Central Storage</h3>
            <p id="storageBerries">Berries: 0</p>
            <p id="storageWood">Wood: 0</p>
            <p id="storageFood">Food (Meat): 0</p>
        </div>
        <p class="text-sm text-gray-600 mt-4">Click human to select. Click ground to move. Click resource (bush/tree/rabbit) to target.</p>
        <button id="resetButton">Reset Simulation</button>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const selectedHumanInfoDiv = document.getElementById('selectedHumanInfo');
        const storageBerriesDiv = document.getElementById('storageBerries');
        const storageWoodDiv = document.getElementById('storageWood');
        const storageFoodDiv = document.getElementById('storageFood'); // For hunted food
        const resetButton = document.getElementById('resetButton');

        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        // --- Global State ---
        let humans = [];
        let berryBushes = [];
        let trees = [];
        let rabbits = [];
        let storage = {
            x: canvasWidth / 2,
            y: canvasHeight / 2,
            size: 25,
            berries: 0,
            wood: 0,
            food: 0, // Generic food from hunting
            color: '#a1887f' // Brownish color for storage area
        };
        let selectedHuman = null;
        let animationFrameId = null;

        // --- Constants ---
        const HUMAN_SIZE = 10;
        const BUSH_SIZE = 12;
        const TREE_SIZE = 15;
        const RABBIT_SIZE = 6;
        const HUMAN_SPEED = 1;
        const RABBIT_SPEED = 0.7;
        const MAX_HUNGER = 100;
        const HUNGER_DECAY_RATE = 0.05;
        const HUNGER_THRESHOLD_TO_EAT = 50; // Eat if below this and food is available
        const HUNGER_THRESHOLD_TO_GATHER = 70; // Seek food if below this
        const GATHER_DISTANCE = 15; // How close to interact
        const CARRY_CAPACITY = 5; // Max resources a human can carry

        // Resource specific constants
        const BERRIES_PER_BUSH = 5;
        const WOOD_PER_TREE = 10;
        const FOOD_PER_RABBIT = 15; // Amount of 'food' gained from hunting a rabbit
        const HUNGER_PER_BERRY = 20;
        const HUNGER_PER_FOOD = 25; // Hunger restored by eating 'food' from storage

        // Action Durations (in frames)
        const GATHER_BERRY_DURATION = 60;
        const CHOP_WOOD_DURATION = 90;
        const HUNT_RABBIT_DURATION = 75; // Time to 'catch' rabbit when close

        // --- Classes ---

        class Human {
            constructor(x, y, id, gender) {
                this.x = x;
                this.y = y;
                this.id = id;
                this.gender = gender;
                this.color = gender === 'M' ? '#4a90e2' : '#e91e63';
                this.size = HUMAN_SIZE;
                this.hunger = MAX_HUNGER;
                this.destination = { x: x, y: y };

                // Task / Targetting
                this.task = 'idle'; // idle, moving, gathering_berries, chopping_wood, hunting, returning_storage, eating
                this.target = null; // Can be bush, tree, rabbit, or storage coords {x,y}
                this.actionTimer = 0;

                // Inventory
                this.berriesCarried = 0;
                this.woodCarried = 0;
                this.foodCarried = 0; // Carrying hunted food

                this.isSelected = false;
            }

            draw() {
                // Draw human body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Selection indicator
                if (this.isSelected) {
                    ctx.strokeStyle = '#FFD700'; // Gold
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Hunger bar
                const barWidth = this.size * 1.5;
                const barHeight = 4;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.size / 2 - barHeight - 2;
                ctx.fillStyle = '#e0e0e0';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                const hungerPercent = this.hunger / MAX_HUNGER;
                let hungerBarColor = '#4caf50';
                if (hungerPercent < 0.6) hungerBarColor = '#ff9800';
                if (hungerPercent < 0.3) hungerBarColor = '#f44336';
                ctx.fillStyle = hungerBarColor;
                ctx.fillRect(barX, barY, barWidth * hungerPercent, barHeight);

                 // Simple carry indicator (optional)
                 const carriedTotal = this.berriesCarried + this.woodCarried + this.foodCarried;
                 if (carriedTotal > 0) {
                     ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                     ctx.beginPath();
                     // Draw a small square next to the human
                     ctx.rect(this.x + this.size / 2, this.y - this.size / 4, 4, 4);
                     ctx.fill();
                 }
            }

            update() {
                // 1. Update Needs
                this.hunger -= HUNGER_DECAY_RATE;
                if (this.hunger < 0) this.hunger = 0;
                // TODO: Consequences of zero hunger

                // 2. Execute Current Action State
                this.executeTask();

                // 3. Decide Next Action (if idle or finished task)
                if (this.task === 'idle') {
                    this.decideNextAction();
                }
            }

            executeTask() {
                switch (this.task) {
                    case 'moving':
                        this.moveTowards(this.destination.x, this.destination.y);
                        if (this.hasReached(this.destination.x, this.destination.y)) {
                            this.task = 'idle';
                        }
                        break;
                    case 'gathering_berries':
                    case 'chopping_wood':
                    case 'hunting':
                        this.performAction();
                        break; // Don't move while performing timed action
                    case 'returning_storage':
                        this.moveTowards(storage.x, storage.y);
                        if (this.hasReached(storage.x, storage.y)) {
                            this.depositResources();
                            this.task = 'idle'; // Decide next after depositing
                        }
                        break;
                    case 'eating':
                         this.performAction(); // Eating takes time
                        break;
                    case 'idle':
                        // Do nothing, wait for decision
                        break;
                }
            }

             performAction() {
                 this.actionTimer++;
                 let duration = 0;
                 let resourceGained = false;

                 if (this.task === 'gathering_berries' && this.target instanceof BerryBush) {
                     duration = GATHER_BERRY_DURATION;
                     if (this.actionTimer >= duration) {
                         if (this.target.berries > 0) {
                             this.target.berries--;
                             this.berriesCarried++;
                             resourceGained = true;
                         } else {
                             this.target = null; // Target depleted mid-action
                         }
                     }
                 } else if (this.task === 'chopping_wood' && this.target instanceof Tree) {
                     duration = CHOP_WOOD_DURATION;
                     if (this.actionTimer >= duration) {
                          if (this.target.wood > 0) {
                             this.target.wood--;
                             this.woodCarried++;
                             resourceGained = true;
                             if (this.target.wood <= 0) {
                                 // Remove the tree when depleted
                                 trees = trees.filter(t => t !== this.target);
                                 this.target = null;
                             }
                          } else {
                              this.target = null; // Target depleted mid-action (e.g. removed already)
                          }
                     }
                 } else if (this.task === 'hunting' && this.target instanceof Rabbit) {
                     duration = HUNT_RABBIT_DURATION;
                     if (this.actionTimer >= duration) {
                         if (this.target.isAlive) { // Check if rabbit still exists
                             this.target.isAlive = false; // Mark rabbit as caught
                             this.foodCarried++;
                             resourceGained = true;
                             // Rabbit will be removed in main loop based on isAlive flag
                         }
                         this.target = null; // Stop targeting after attempt
                     }
                 } else if (this.task === 'eating') {
                     duration = GATHER_BERRY_DURATION; // Eating takes same time as gathering
                     if (this.actionTimer >= duration) {
                         if (storage.berries > 0 && this.hunger < MAX_HUNGER) {
                             storage.berries--;
                             this.hunger += HUNGER_PER_BERRY;
                         } else if (storage.food > 0 && this.hunger < MAX_HUNGER) {
                             storage.food--;
                             this.hunger += HUNGER_PER_FOOD;
                         }
                         if (this.hunger >= MAX_HUNGER) {
                             this.hunger = MAX_HUNGER;
                             this.task = 'idle'; // Stop eating when full
                         } else if (storage.berries === 0 && storage.food === 0) {
                             this.task = 'idle'; // Stop eating if storage is empty
                         }
                         this.actionTimer = 0; // Reset timer for next bite or stop
                     }
                 }


                 // If action finished or target became invalid
                 if (this.actionTimer >= duration || this.target === null && (this.task === 'gathering_berries' || this.task === 'chopping_wood' || this.task === 'hunting')) {
                     this.actionTimer = 0;
                     // If carrying capacity reached or no more resources at target, return to storage
                     const carriedTotal = this.berriesCarried + this.woodCarried + this.foodCarried;
                     if (carriedTotal >= CARRY_CAPACITY || !resourceGained || (this.target && (this.target.berries === 0 || this.target.wood === 0))) {
                         this.task = 'returning_storage';
                         this.target = null; // Clear specific resource target
                     } else {
                         // Continue action on the same target if possible (e.g. gather another berry)
                         // Reset timer handled above, task remains the same
                     }
                 }
             }

            decideNextAction() {
                const carriedTotal = this.berriesCarried + this.woodCarried + this.foodCarried;

                // Priority 1: Eat if hungry and food available at storage
                if (this.hunger < HUNGER_THRESHOLD_TO_EAT && (storage.berries > 0 || storage.food > 0)) {
                    // Move to storage if not already there
                    if (!this.hasReached(storage.x, storage.y)) {
                        this.task = 'moving';
                        this.destination = {x: storage.x, y: storage.y};
                        this.target = null; // Ensure no resource target while moving to eat
                    } else {
                        this.task = 'eating';
                        this.actionTimer = 0;
                    }
                    return; // Decision made
                }

                // Priority 2: Return to storage if inventory is full
                if (carriedTotal >= CARRY_CAPACITY) {
                    this.task = 'returning_storage';
                    this.target = null;
                    return; // Decision made
                }

                // Priority 3: Gather resources if needed (e.g., low hunger or assigned task - basic needs first)
                if (this.hunger < HUNGER_THRESHOLD_TO_GATHER) {
                    // Find food first (prioritize hunting then berries)
                    let foodTarget = this.findClosestReachable(rabbits.filter(r => r.isAlive));
                    if (foodTarget) {
                        this.target = foodTarget;
                        this.task = 'moving';
                        this.destination = {x: foodTarget.x, y: foodTarget.y};
                        // Task will change to 'hunting' upon reaching target via moveTowards logic
                        return;
                    }
                    let berryTarget = this.findClosestReachable(berryBushes.filter(b => b.berries > 0));
                     if (berryTarget) {
                         this.target = berryTarget;
                         this.task = 'moving';
                         this.destination = {x: berryTarget.x, y: berryTarget.y};
                         // Task will change to 'gathering_berries' upon reaching target
                         return;
                     }
                }

                 // Priority 4: Gather wood if nothing else pressing (basic placeholder)
                 // In a real game, this would be driven by build orders or job assignments
                 if (carriedTotal === 0) { // Only gather wood if empty handed and not hungry
                     let woodTarget = this.findClosestReachable(trees.filter(t => t.wood > 0));
                     if (woodTarget) {
                         this.target = woodTarget;
                         this.task = 'moving';
                         this.destination = { x: woodTarget.x, y: woodTarget.y };
                         // Task will change to 'chopping_wood' upon reaching target
                         return;
                     }
                 }


                // Default: Wander or stay idle (could be improved)
                this.task = 'idle'; // Stay idle if no pressing needs or available resources
            }

            moveTowards(targetX, targetY) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > GATHER_DISTANCE / 2) { // Use smaller threshold for stopping move
                    const moveX = (dx / distance) * HUMAN_SPEED;
                    const moveY = (dy / distance) * HUMAN_SPEED;
                    const nextX = this.x + moveX;
                    const nextY = this.y + moveY;

                    // Boundary check
                    if (nextX > this.size / 2 && nextX < canvasWidth - this.size / 2) this.x = nextX;
                    if (nextY > this.size / 2 && nextY < canvasHeight - this.size / 2) this.y = nextY;

                    // Check if reached resource target to switch task
                     if (this.target && this.hasReached(this.target.x, this.target.y)) {
                         this.actionTimer = 0; // Reset timer for the action
                         if (this.target instanceof BerryBush) this.task = 'gathering_berries';
                         else if (this.target instanceof Tree) this.task = 'chopping_wood';
                         else if (this.target instanceof Rabbit) this.task = 'hunting';
                         // No else needed for storage, handled in 'returning_storage' state
                     }

                } else {
                     // Already close enough, potentially switch task if moving towards resource
                     if (this.target && this.task === 'moving') {
                          this.actionTimer = 0;
                          if (this.target instanceof BerryBush) this.task = 'gathering_berries';
                          else if (this.target instanceof Tree) this.task = 'chopping_wood';
                          else if (this.target instanceof Rabbit) this.task = 'hunting';
                          else { // Reached a non-resource destination
                              this.task = 'idle';
                              this.destination = {x: this.x, y: this.y}; // Update destination to current spot
                          }
                     } else if (this.task === 'moving') { // Reached non-resource destination
                         this.task = 'idle';
                         this.destination = {x: this.x, y: this.y};
                     }
                }
            }

            hasReached(targetX, targetY) {
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance <= GATHER_DISTANCE; // Use interaction distance
            }

            setManualDestination(x, y) {
                this.destination.x = x;
                this.destination.y = y;
                this.target = null; // Manual move overrides any target
                this.task = 'moving';
                this.actionTimer = 0;
            }

             setManualTarget(resource) {
                 if (resource instanceof BerryBush || resource instanceof Tree || resource instanceof Rabbit) {
                     // Check if resource is valid (e.g., has berries/wood, is alive)
                     if ((resource instanceof BerryBush && resource.berries > 0) ||
                         (resource instanceof Tree && resource.wood > 0) ||
                         (resource instanceof Rabbit && resource.isAlive))
                     {
                         this.target = resource;
                         this.destination = { x: resource.x, y: resource.y }; // Set destination to target
                         this.task = 'moving'; // Start moving towards it
                         this.actionTimer = 0;
                     } else {
                         console.log("Cannot target depleted/invalid resource.");
                         this.target = null;
                         this.task = 'idle';
                     }
                 } else {
                      console.log("Invalid target type");
                 }
             }


            findClosestReachable(resourceList) {
                let closest = null;
                let minDistance = Infinity;
                resourceList.forEach(resource => {
                     // Basic check if resource is valid (e.g. has berries/wood or is alive)
                     let isValid = false;
                     if (resource instanceof BerryBush && resource.berries > 0) isValid = true;
                     else if (resource instanceof Tree && resource.wood > 0) isValid = true;
                     else if (resource instanceof Rabbit && resource.isAlive) isValid = true;

                     if (isValid) {
                        const dx = resource.x - this.x;
                        const dy = resource.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closest = resource;
                        }
                     }
                });
                return closest;
            }

            depositResources() {
                storage.berries += this.berriesCarried;
                storage.wood += this.woodCarried;
                storage.food += this.foodCarried; // Add hunted food
                this.berriesCarried = 0;
                this.woodCarried = 0;
                this.foodCarried = 0;
                updateStorageInfo(); // Update UI
            }
        }

        class BerryBush {
             constructor(x, y) { /* ... (same as before) ... */
                this.x = x;
                this.y = y;
                this.size = BUSH_SIZE;
                this.color = '#2e7d32'; // Dark Green
                this.berries = BERRIES_PER_BUSH;
                this.maxBerries = BERRIES_PER_BUSH;
                this.regenTimer = 0;
                this.regenRate = 500; // Frames to regenerate one berry
            }
            draw() { /* ... (same as before) ... */
                // Draw bush body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw berries on top (small red dots)
                ctx.fillStyle = '#d32f2f'; // Red
                const berrySize = 2;
                for (let i = 0; i < this.berries; i++) {
                    // Simple circular arrangement for berries
                    const angle = (i / this.maxBerries) * Math.PI * 2 + Math.PI / 4; // Offset start angle
                    const berryX = this.x + Math.cos(angle) * (this.size / 3);
                    const berryY = this.y + Math.sin(angle) * (this.size / 3);
                    ctx.beginPath();
                    ctx.arc(berryX, berryY, berrySize, 0, Math.PI * 2);
                    ctx.fill();
                }
                 // Draw outline if empty
                 if (this.berries === 0) {
                      ctx.strokeStyle = '#a5a5a5'; // Gray outline
                      ctx.lineWidth = 1;
                      ctx.beginPath();
                      ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
                      ctx.stroke();
                 }
            }
            update() { /* ... (same as before) ... */
                 // Regenerate berries if not full
                 if (this.berries < this.maxBerries) {
                     this.regenTimer++;
                     if (this.regenTimer >= this.regenRate) {
                         this.regenTimer = 0;
                         this.berries++;
                     }
                 }
            }
        }

        class Tree {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = TREE_SIZE;
                this.color = '#8d6e63'; // Brown trunk
                this.foliageColor = '#66bb6a'; // Green foliage
                this.wood = WOOD_PER_TREE;
                this.maxWood = WOOD_PER_TREE;
            }

            draw() {
                // Draw trunk
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size / 4, this.y - this.size / 2, this.size / 2, this.size);

                // Draw foliage (circle on top)
                ctx.fillStyle = this.foliageColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y - this.size / 2, this.size * 0.6, 0, Math.PI * 2);
                ctx.fill();

                 // Indicate remaining wood (optional - change foliage size/color?)
                 const woodPercent = this.wood / this.maxWood;
                 ctx.fillStyle = `rgba(102, 187, 106, ${0.5 + woodPercent * 0.5})`; // Fade foliage slightly as wood depletes
                 ctx.beginPath();
                 ctx.arc(this.x, this.y - this.size / 2, this.size * 0.6 * woodPercent, 0, Math.PI * 2);
                 ctx.fill();
            }
             // Trees don't regenerate in this simple version
             update() {}
        }

         class Rabbit {
             constructor(x, y) {
                 this.x = x;
                 this.y = y;
                 this.size = RABBIT_SIZE;
                 this.color = '#bdbdbd'; // Gray
                 this.isAlive = true;
                 this.wanderAngle = Math.random() * Math.PI * 2;
                 this.wanderTimer = 0;
                 this.wanderInterval = 120 + Math.random() * 180; // Change direction every 2-5 seconds
             }

             draw() {
                 if (!this.isAlive) return;
                 ctx.fillStyle = this.color;
                 ctx.beginPath();
                 // Simple oval shape
                 ctx.ellipse(this.x, this.y, this.size, this.size / 1.5, 0, 0, Math.PI * 2);
                 ctx.fill();
             }

             update() {
                 if (!this.isAlive) return;

                 // Wander behavior
                 this.wanderTimer++;
                 if (this.wanderTimer >= this.wanderInterval) {
                     this.wanderAngle += (Math.random() - 0.5) * Math.PI; // Change angle slightly
                     this.wanderTimer = 0;
                     this.wanderInterval = 120 + Math.random() * 180;
                 }

                 const moveX = Math.cos(this.wanderAngle) * RABBIT_SPEED;
                 const moveY = Math.sin(this.wanderAngle) * RABBIT_SPEED;
                 const nextX = this.x + moveX;
                 const nextY = this.y + moveY;

                 // Boundary check - bounce off edges crudely
                 if (nextX < this.size || nextX > canvasWidth - this.size) {
                     this.wanderAngle = Math.PI - this.wanderAngle; // Reverse horizontal component
                 } else {
                     this.x = nextX;
                 }
                 if (nextY < this.size || nextY > canvasHeight - this.size) {
                     this.wanderAngle = -this.wanderAngle; // Reverse vertical component
                 } else {
                     this.y = nextY;
                 }
             }
         }


        // --- Simulation Functions ---

        function initSimulation() {
             // Clear previous state
             humans = [];
             berryBushes = [];
             trees = [];
             rabbits = [];
             selectedHuman = null;
             if (animationFrameId) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
             }

            // Reset storage
            storage.berries = 0;
            storage.wood = 0;
            storage.food = 0;


            // Create initial humans
            humans.push(new Human(storage.x - 50, storage.y - 50, 1, 'M'));
            humans.push(new Human(storage.x + 50, storage.y - 50, 2, 'F'));
            humans.push(new Human(storage.x - 50, storage.y + 50, 3, 'M'));
            humans.push(new Human(storage.x + 50, storage.y + 50, 4, 'F'));

            // Create resources
            const numBushes = 15;
            const numTrees = 10;
            const numRabbits = 5;

            for (let i = 0; i < numBushes; i++) spawnResource(BerryBush, berryBushes);
            for (let i = 0; i < numTrees; i++) spawnResource(Tree, trees);
            for (let i = 0; i < numRabbits; i++) spawnResource(Rabbit, rabbits);


            updateStorageInfo();
            updateSelectedInfo();
            gameLoop();
        }

         // Helper to spawn resources away from the center storage
         function spawnResource(ResourceType, list) {
             let x, y, distance;
             const minSpawnDist = 80; // Minimum distance from storage
             do {
                 x = Math.random() * (canvasWidth - 20) + 10; // Padding from edge
                 y = Math.random() * (canvasHeight - 20) + 10;
                 const dx = x - storage.x;
                 const dy = y - storage.y;
                 distance = Math.sqrt(dx * dx + dy * dy);
             } while (distance < minSpawnDist); // Keep trying until far enough
             list.push(new ResourceType(x, y));
         }


        function gameLoop() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Draw Storage Area
            ctx.fillStyle = storage.color;
            ctx.globalAlpha = 0.3; // Make it semi-transparent
            ctx.fillRect(storage.x - storage.size / 2, storage.y - storage.size / 2, storage.size, storage.size);
            ctx.globalAlpha = 1.0; // Reset alpha
            ctx.strokeStyle = storage.color;
            ctx.strokeRect(storage.x - storage.size / 2, storage.y - storage.size / 2, storage.size, storage.size);


            // Update and draw resources
            [...berryBushes, ...trees, ...rabbits].forEach(r => {
                 if (r.update) r.update(); // Rabbits update/move
                 r.draw();
            });

             // Remove caught rabbits
             rabbits = rabbits.filter(r => r.isAlive);

            // Update and draw humans
            humans.forEach(human => {
                human.update();
                human.draw();
            });

            updateSelectedInfo(); // Update UI

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function updateSelectedInfo() {
            if (selectedHuman) {
                const hungerPercent = ((selectedHuman.hunger / MAX_HUNGER) * 100).toFixed(0);
                let progressBarClass = 'progress-bar';
                 if (hungerPercent < 60) progressBarClass += ' low';
                 if (hungerPercent < 30) progressBarClass += ' critical';
                 const carried = `Berries: ${selectedHuman.berriesCarried}, Wood: ${selectedHuman.woodCarried}, Food: ${selectedHuman.foodCarried}`;

                selectedHumanInfoDiv.innerHTML = `
                    <p><b>Selected:</b> Human ${selectedHuman.id} (${selectedHuman.gender})</p>
                    <p><b>Task:</b> ${selectedHuman.task.replace('_', ' ')}</p>
                    <p><b>Hunger:</b></p>
                    <div class="progress-bar-container">
                        <div class="${progressBarClass}" style="width: ${hungerPercent}%">${hungerPercent}%</div>
                    </div>
                     <p class="mt-1"><b>Carrying:</b> ${carried}</p>
                     <p class="mt-1"><b>Target:</b> ${selectedHuman.target ? selectedHuman.target.constructor.name : 'None'}</p>
                `;
            } else {
                selectedHumanInfoDiv.innerHTML = '<p>Select a human to see details.</p>';
            }
        }

         function updateStorageInfo() {
             storageBerriesDiv.textContent = `Berries: ${storage.berries}`;
             storageWoodDiv.textContent = `Wood: ${storage.wood}`;
             storageFoodDiv.textContent = `Food (Meat): ${storage.food}`;
         }

        // --- Event Listeners ---

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            let clickedOnHuman = null;
            let clickedOnResource = null;

            // Check human click
            humans.forEach(human => {
                if (isClickOn(clickX, clickY, human)) {
                    clickedOnHuman = human;
                }
            });

            // If not clicking a human, check resource click
            if (!clickedOnHuman) {
                clickedOnResource = [...berryBushes, ...trees, ...rabbits].find(r => isClickOn(clickX, clickY, r));
            }

            if (clickedOnHuman) {
                // Select the clicked human
                if (selectedHuman) selectedHuman.isSelected = false;
                selectedHuman = clickedOnHuman;
                selectedHuman.isSelected = true;
            } else if (clickedOnResource && selectedHuman) {
                 // Command selected human to target the resource
                 selectedHuman.setManualTarget(clickedOnResource);
            } else if (selectedHuman) {
                // Command selected human to move to the clicked point
                selectedHuman.setManualDestination(clickX, clickY);
            }

            updateSelectedInfo(); // Update UI after any click interaction
        });

         // Helper function for click detection
         function isClickOn(clickX, clickY, entity) {
              if (!entity || (entity instanceof Rabbit && !entity.isAlive)) return false; // Ignore dead rabbits
              const dx = clickX - entity.x;
              const dy = clickY - entity.y;
              // Use slightly larger radius for easier clicking
              const clickRadius = (entity.size / 2) * 1.5;
              return (dx * dx + dy * dy) < (clickRadius * clickRadius);
         }


         resetButton.addEventListener('click', initSimulation);

        // --- Initialisation ---
        initSimulation();

    </script>

</body>
</html>
